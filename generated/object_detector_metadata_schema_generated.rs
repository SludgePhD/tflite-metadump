// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod mediapipe {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod tasks {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum FixedAnchorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FixedAnchor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FixedAnchor<'a> {
  type Inner = FixedAnchor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FixedAnchor<'a> {
  pub const VT_X_CENTER: flatbuffers::VOffsetT = 4;
  pub const VT_Y_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 8;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FixedAnchor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FixedAnchorArgs
  ) -> flatbuffers::WIPOffset<FixedAnchor<'bldr>> {
    let mut builder = FixedAnchorBuilder::new(_fbb);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_y_center(args.y_center);
    builder.add_x_center(args.x_center);
    builder.finish()
  }


  #[inline]
  pub fn x_center(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FixedAnchor::VT_X_CENTER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_center(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FixedAnchor::VT_Y_CENTER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FixedAnchor::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FixedAnchor::VT_HEIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FixedAnchor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x_center", Self::VT_X_CENTER, false)?
     .visit_field::<f32>("y_center", Self::VT_Y_CENTER, false)?
     .visit_field::<f32>("width", Self::VT_WIDTH, false)?
     .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct FixedAnchorArgs {
    pub x_center: f32,
    pub y_center: f32,
    pub width: f32,
    pub height: f32,
}
impl<'a> Default for FixedAnchorArgs {
  #[inline]
  fn default() -> Self {
    FixedAnchorArgs {
      x_center: 0.0,
      y_center: 0.0,
      width: 0.0,
      height: 0.0,
    }
  }
}

pub struct FixedAnchorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FixedAnchorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x_center(&mut self, x_center: f32) {
    self.fbb_.push_slot::<f32>(FixedAnchor::VT_X_CENTER, x_center, 0.0);
  }
  #[inline]
  pub fn add_y_center(&mut self, y_center: f32) {
    self.fbb_.push_slot::<f32>(FixedAnchor::VT_Y_CENTER, y_center, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f32) {
    self.fbb_.push_slot::<f32>(FixedAnchor::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f32) {
    self.fbb_.push_slot::<f32>(FixedAnchor::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FixedAnchorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FixedAnchorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FixedAnchor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FixedAnchor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FixedAnchor");
      ds.field("x_center", &self.x_center());
      ds.field("y_center", &self.y_center());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.finish()
  }
}
pub enum FixedAnchorsSchemaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FixedAnchorsSchema<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FixedAnchorsSchema<'a> {
  type Inner = FixedAnchorsSchema<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FixedAnchorsSchema<'a> {
  pub const VT_ANCHORS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FixedAnchorsSchema { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FixedAnchorsSchemaArgs<'args>
  ) -> flatbuffers::WIPOffset<FixedAnchorsSchema<'bldr>> {
    let mut builder = FixedAnchorsSchemaBuilder::new(_fbb);
    if let Some(x) = args.anchors { builder.add_anchors(x); }
    builder.finish()
  }


  #[inline]
  pub fn anchors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FixedAnchor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FixedAnchor>>>>(FixedAnchorsSchema::VT_ANCHORS, None)}
  }
}

impl flatbuffers::Verifiable for FixedAnchorsSchema<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FixedAnchor>>>>("anchors", Self::VT_ANCHORS, false)?
     .finish();
    Ok(())
  }
}
pub struct FixedAnchorsSchemaArgs<'a> {
    pub anchors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FixedAnchor<'a>>>>>,
}
impl<'a> Default for FixedAnchorsSchemaArgs<'a> {
  #[inline]
  fn default() -> Self {
    FixedAnchorsSchemaArgs {
      anchors: None,
    }
  }
}

pub struct FixedAnchorsSchemaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FixedAnchorsSchemaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_anchors(&mut self, anchors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FixedAnchor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FixedAnchorsSchema::VT_ANCHORS, anchors);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FixedAnchorsSchemaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FixedAnchorsSchemaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FixedAnchorsSchema<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FixedAnchorsSchema<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FixedAnchorsSchema");
      ds.field("anchors", &self.anchors());
      ds.finish()
  }
}
pub enum SsdAnchorsOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SsdAnchorsOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SsdAnchorsOptions<'a> {
  type Inner = SsdAnchorsOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SsdAnchorsOptions<'a> {
  pub const VT_FIXED_ANCHORS_SCHEMA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SsdAnchorsOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SsdAnchorsOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<SsdAnchorsOptions<'bldr>> {
    let mut builder = SsdAnchorsOptionsBuilder::new(_fbb);
    if let Some(x) = args.fixed_anchors_schema { builder.add_fixed_anchors_schema(x); }
    builder.finish()
  }


  #[inline]
  pub fn fixed_anchors_schema(&self) -> Option<FixedAnchorsSchema<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FixedAnchorsSchema>>(SsdAnchorsOptions::VT_FIXED_ANCHORS_SCHEMA, None)}
  }
}

impl flatbuffers::Verifiable for SsdAnchorsOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<FixedAnchorsSchema>>("fixed_anchors_schema", Self::VT_FIXED_ANCHORS_SCHEMA, false)?
     .finish();
    Ok(())
  }
}
pub struct SsdAnchorsOptionsArgs<'a> {
    pub fixed_anchors_schema: Option<flatbuffers::WIPOffset<FixedAnchorsSchema<'a>>>,
}
impl<'a> Default for SsdAnchorsOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    SsdAnchorsOptionsArgs {
      fixed_anchors_schema: None,
    }
  }
}

pub struct SsdAnchorsOptionsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SsdAnchorsOptionsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_fixed_anchors_schema(&mut self, fixed_anchors_schema: flatbuffers::WIPOffset<FixedAnchorsSchema<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FixedAnchorsSchema>>(SsdAnchorsOptions::VT_FIXED_ANCHORS_SCHEMA, fixed_anchors_schema);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SsdAnchorsOptionsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SsdAnchorsOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SsdAnchorsOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SsdAnchorsOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SsdAnchorsOptions");
      ds.field("fixed_anchors_schema", &self.fixed_anchors_schema());
      ds.finish()
  }
}
pub enum TensorsDecodingOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorsDecodingOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorsDecodingOptions<'a> {
  type Inner = TensorsDecodingOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorsDecodingOptions<'a> {
  pub const VT_NUM_CLASSES: flatbuffers::VOffsetT = 4;
  pub const VT_NUM_BOXES: flatbuffers::VOffsetT = 6;
  pub const VT_NUM_COORDS: flatbuffers::VOffsetT = 8;
  pub const VT_KEYPOINT_COORD_OFFSET: flatbuffers::VOffsetT = 10;
  pub const VT_NUM_KEYPOINTS: flatbuffers::VOffsetT = 12;
  pub const VT_NUM_VALUES_PER_KEYPOINT: flatbuffers::VOffsetT = 14;
  pub const VT_X_SCALE: flatbuffers::VOffsetT = 16;
  pub const VT_Y_SCALE: flatbuffers::VOffsetT = 18;
  pub const VT_W_SCALE: flatbuffers::VOffsetT = 20;
  pub const VT_H_SCALE: flatbuffers::VOffsetT = 22;
  pub const VT_APPLY_EXPONENTIAL_ON_BOX_SIZE: flatbuffers::VOffsetT = 24;
  pub const VT_SIGMOID_SCORE: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorsDecodingOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TensorsDecodingOptionsArgs
  ) -> flatbuffers::WIPOffset<TensorsDecodingOptions<'bldr>> {
    let mut builder = TensorsDecodingOptionsBuilder::new(_fbb);
    builder.add_h_scale(args.h_scale);
    builder.add_w_scale(args.w_scale);
    builder.add_y_scale(args.y_scale);
    builder.add_x_scale(args.x_scale);
    builder.add_num_values_per_keypoint(args.num_values_per_keypoint);
    builder.add_num_keypoints(args.num_keypoints);
    builder.add_keypoint_coord_offset(args.keypoint_coord_offset);
    builder.add_num_coords(args.num_coords);
    builder.add_num_boxes(args.num_boxes);
    builder.add_num_classes(args.num_classes);
    builder.add_sigmoid_score(args.sigmoid_score);
    builder.add_apply_exponential_on_box_size(args.apply_exponential_on_box_size);
    builder.finish()
  }


  #[inline]
  pub fn num_classes(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorsDecodingOptions::VT_NUM_CLASSES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn num_boxes(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorsDecodingOptions::VT_NUM_BOXES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn num_coords(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorsDecodingOptions::VT_NUM_COORDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn keypoint_coord_offset(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorsDecodingOptions::VT_KEYPOINT_COORD_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn num_keypoints(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorsDecodingOptions::VT_NUM_KEYPOINTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn num_values_per_keypoint(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorsDecodingOptions::VT_NUM_VALUES_PER_KEYPOINT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn x_scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorsDecodingOptions::VT_X_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorsDecodingOptions::VT_Y_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn w_scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorsDecodingOptions::VT_W_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn h_scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorsDecodingOptions::VT_H_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn apply_exponential_on_box_size(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorsDecodingOptions::VT_APPLY_EXPONENTIAL_ON_BOX_SIZE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn sigmoid_score(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorsDecodingOptions::VT_SIGMOID_SCORE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TensorsDecodingOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num_classes", Self::VT_NUM_CLASSES, false)?
     .visit_field::<i32>("num_boxes", Self::VT_NUM_BOXES, false)?
     .visit_field::<i32>("num_coords", Self::VT_NUM_COORDS, false)?
     .visit_field::<i32>("keypoint_coord_offset", Self::VT_KEYPOINT_COORD_OFFSET, false)?
     .visit_field::<i32>("num_keypoints", Self::VT_NUM_KEYPOINTS, false)?
     .visit_field::<i32>("num_values_per_keypoint", Self::VT_NUM_VALUES_PER_KEYPOINT, false)?
     .visit_field::<f32>("x_scale", Self::VT_X_SCALE, false)?
     .visit_field::<f32>("y_scale", Self::VT_Y_SCALE, false)?
     .visit_field::<f32>("w_scale", Self::VT_W_SCALE, false)?
     .visit_field::<f32>("h_scale", Self::VT_H_SCALE, false)?
     .visit_field::<bool>("apply_exponential_on_box_size", Self::VT_APPLY_EXPONENTIAL_ON_BOX_SIZE, false)?
     .visit_field::<bool>("sigmoid_score", Self::VT_SIGMOID_SCORE, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorsDecodingOptionsArgs {
    pub num_classes: i32,
    pub num_boxes: i32,
    pub num_coords: i32,
    pub keypoint_coord_offset: i32,
    pub num_keypoints: i32,
    pub num_values_per_keypoint: i32,
    pub x_scale: f32,
    pub y_scale: f32,
    pub w_scale: f32,
    pub h_scale: f32,
    pub apply_exponential_on_box_size: bool,
    pub sigmoid_score: bool,
}
impl<'a> Default for TensorsDecodingOptionsArgs {
  #[inline]
  fn default() -> Self {
    TensorsDecodingOptionsArgs {
      num_classes: 0,
      num_boxes: 0,
      num_coords: 0,
      keypoint_coord_offset: 0,
      num_keypoints: 0,
      num_values_per_keypoint: 0,
      x_scale: 0.0,
      y_scale: 0.0,
      w_scale: 0.0,
      h_scale: 0.0,
      apply_exponential_on_box_size: false,
      sigmoid_score: false,
    }
  }
}

pub struct TensorsDecodingOptionsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TensorsDecodingOptionsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_num_classes(&mut self, num_classes: i32) {
    self.fbb_.push_slot::<i32>(TensorsDecodingOptions::VT_NUM_CLASSES, num_classes, 0);
  }
  #[inline]
  pub fn add_num_boxes(&mut self, num_boxes: i32) {
    self.fbb_.push_slot::<i32>(TensorsDecodingOptions::VT_NUM_BOXES, num_boxes, 0);
  }
  #[inline]
  pub fn add_num_coords(&mut self, num_coords: i32) {
    self.fbb_.push_slot::<i32>(TensorsDecodingOptions::VT_NUM_COORDS, num_coords, 0);
  }
  #[inline]
  pub fn add_keypoint_coord_offset(&mut self, keypoint_coord_offset: i32) {
    self.fbb_.push_slot::<i32>(TensorsDecodingOptions::VT_KEYPOINT_COORD_OFFSET, keypoint_coord_offset, 0);
  }
  #[inline]
  pub fn add_num_keypoints(&mut self, num_keypoints: i32) {
    self.fbb_.push_slot::<i32>(TensorsDecodingOptions::VT_NUM_KEYPOINTS, num_keypoints, 0);
  }
  #[inline]
  pub fn add_num_values_per_keypoint(&mut self, num_values_per_keypoint: i32) {
    self.fbb_.push_slot::<i32>(TensorsDecodingOptions::VT_NUM_VALUES_PER_KEYPOINT, num_values_per_keypoint, 0);
  }
  #[inline]
  pub fn add_x_scale(&mut self, x_scale: f32) {
    self.fbb_.push_slot::<f32>(TensorsDecodingOptions::VT_X_SCALE, x_scale, 0.0);
  }
  #[inline]
  pub fn add_y_scale(&mut self, y_scale: f32) {
    self.fbb_.push_slot::<f32>(TensorsDecodingOptions::VT_Y_SCALE, y_scale, 0.0);
  }
  #[inline]
  pub fn add_w_scale(&mut self, w_scale: f32) {
    self.fbb_.push_slot::<f32>(TensorsDecodingOptions::VT_W_SCALE, w_scale, 0.0);
  }
  #[inline]
  pub fn add_h_scale(&mut self, h_scale: f32) {
    self.fbb_.push_slot::<f32>(TensorsDecodingOptions::VT_H_SCALE, h_scale, 0.0);
  }
  #[inline]
  pub fn add_apply_exponential_on_box_size(&mut self, apply_exponential_on_box_size: bool) {
    self.fbb_.push_slot::<bool>(TensorsDecodingOptions::VT_APPLY_EXPONENTIAL_ON_BOX_SIZE, apply_exponential_on_box_size, false);
  }
  #[inline]
  pub fn add_sigmoid_score(&mut self, sigmoid_score: bool) {
    self.fbb_.push_slot::<bool>(TensorsDecodingOptions::VT_SIGMOID_SCORE, sigmoid_score, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TensorsDecodingOptionsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TensorsDecodingOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorsDecodingOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorsDecodingOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorsDecodingOptions");
      ds.field("num_classes", &self.num_classes());
      ds.field("num_boxes", &self.num_boxes());
      ds.field("num_coords", &self.num_coords());
      ds.field("keypoint_coord_offset", &self.keypoint_coord_offset());
      ds.field("num_keypoints", &self.num_keypoints());
      ds.field("num_values_per_keypoint", &self.num_values_per_keypoint());
      ds.field("x_scale", &self.x_scale());
      ds.field("y_scale", &self.y_scale());
      ds.field("w_scale", &self.w_scale());
      ds.field("h_scale", &self.h_scale());
      ds.field("apply_exponential_on_box_size", &self.apply_exponential_on_box_size());
      ds.field("sigmoid_score", &self.sigmoid_score());
      ds.finish()
  }
}
pub enum ObjectDetectorOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ObjectDetectorOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ObjectDetectorOptions<'a> {
  type Inner = ObjectDetectorOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ObjectDetectorOptions<'a> {
  pub const VT_MIN_PARSER_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_SSD_ANCHORS_OPTIONS: flatbuffers::VOffsetT = 6;
  pub const VT_TENSORS_DECODING_OPTIONS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ObjectDetectorOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ObjectDetectorOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<ObjectDetectorOptions<'bldr>> {
    let mut builder = ObjectDetectorOptionsBuilder::new(_fbb);
    if let Some(x) = args.tensors_decoding_options { builder.add_tensors_decoding_options(x); }
    if let Some(x) = args.ssd_anchors_options { builder.add_ssd_anchors_options(x); }
    if let Some(x) = args.min_parser_version { builder.add_min_parser_version(x); }
    builder.finish()
  }


  #[inline]
  pub fn min_parser_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ObjectDetectorOptions::VT_MIN_PARSER_VERSION, None)}
  }
  #[inline]
  pub fn ssd_anchors_options(&self) -> Option<SsdAnchorsOptions<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SsdAnchorsOptions>>(ObjectDetectorOptions::VT_SSD_ANCHORS_OPTIONS, None)}
  }
  #[inline]
  pub fn tensors_decoding_options(&self) -> Option<TensorsDecodingOptions<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TensorsDecodingOptions>>(ObjectDetectorOptions::VT_TENSORS_DECODING_OPTIONS, None)}
  }
}

impl flatbuffers::Verifiable for ObjectDetectorOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("min_parser_version", Self::VT_MIN_PARSER_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SsdAnchorsOptions>>("ssd_anchors_options", Self::VT_SSD_ANCHORS_OPTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TensorsDecodingOptions>>("tensors_decoding_options", Self::VT_TENSORS_DECODING_OPTIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct ObjectDetectorOptionsArgs<'a> {
    pub min_parser_version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ssd_anchors_options: Option<flatbuffers::WIPOffset<SsdAnchorsOptions<'a>>>,
    pub tensors_decoding_options: Option<flatbuffers::WIPOffset<TensorsDecodingOptions<'a>>>,
}
impl<'a> Default for ObjectDetectorOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ObjectDetectorOptionsArgs {
      min_parser_version: None,
      ssd_anchors_options: None,
      tensors_decoding_options: None,
    }
  }
}

pub struct ObjectDetectorOptionsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ObjectDetectorOptionsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_min_parser_version(&mut self, min_parser_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObjectDetectorOptions::VT_MIN_PARSER_VERSION, min_parser_version);
  }
  #[inline]
  pub fn add_ssd_anchors_options(&mut self, ssd_anchors_options: flatbuffers::WIPOffset<SsdAnchorsOptions<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SsdAnchorsOptions>>(ObjectDetectorOptions::VT_SSD_ANCHORS_OPTIONS, ssd_anchors_options);
  }
  #[inline]
  pub fn add_tensors_decoding_options(&mut self, tensors_decoding_options: flatbuffers::WIPOffset<TensorsDecodingOptions<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TensorsDecodingOptions>>(ObjectDetectorOptions::VT_TENSORS_DECODING_OPTIONS, tensors_decoding_options);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ObjectDetectorOptionsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ObjectDetectorOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ObjectDetectorOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ObjectDetectorOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ObjectDetectorOptions");
      ds.field("min_parser_version", &self.min_parser_version());
      ds.field("ssd_anchors_options", &self.ssd_anchors_options());
      ds.field("tensors_decoding_options", &self.tensors_decoding_options());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ObjectDetectorOptions`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_object_detector_options_unchecked`.
pub fn root_as_object_detector_options(buf: &[u8]) -> Result<ObjectDetectorOptions, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ObjectDetectorOptions>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ObjectDetectorOptions` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_object_detector_options_unchecked`.
pub fn size_prefixed_root_as_object_detector_options(buf: &[u8]) -> Result<ObjectDetectorOptions, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ObjectDetectorOptions>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ObjectDetectorOptions` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_object_detector_options_unchecked`.
pub fn root_as_object_detector_options_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ObjectDetectorOptions<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ObjectDetectorOptions<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ObjectDetectorOptions` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_object_detector_options_unchecked`.
pub fn size_prefixed_root_as_object_detector_options_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ObjectDetectorOptions<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ObjectDetectorOptions<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ObjectDetectorOptions and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ObjectDetectorOptions`.
pub unsafe fn root_as_object_detector_options_unchecked(buf: &[u8]) -> ObjectDetectorOptions {
  flatbuffers::root_unchecked::<ObjectDetectorOptions>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ObjectDetectorOptions and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ObjectDetectorOptions`.
pub unsafe fn size_prefixed_root_as_object_detector_options_unchecked(buf: &[u8]) -> ObjectDetectorOptions {
  flatbuffers::size_prefixed_root_unchecked::<ObjectDetectorOptions>(buf)
}
pub const OBJECT_DETECTOR_OPTIONS_IDENTIFIER: &str = "V001";

#[inline]
pub fn object_detector_options_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OBJECT_DETECTOR_OPTIONS_IDENTIFIER, false)
}

#[inline]
pub fn object_detector_options_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OBJECT_DETECTOR_OPTIONS_IDENTIFIER, true)
}

#[inline]
pub fn finish_object_detector_options_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ObjectDetectorOptions<'a>>) {
  fbb.finish(root, Some(OBJECT_DETECTOR_OPTIONS_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_object_detector_options_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ObjectDetectorOptions<'a>>) {
  fbb.finish_size_prefixed(root, Some(OBJECT_DETECTOR_OPTIONS_IDENTIFIER));
}
}  // pub mod tasks
}  // pub mod mediapipe

